{-# LANGUAGE DeriveAnyClass #-}

module TheUnit.Model.Payment.ACHPayment
  ( ACHPayment (..),
    CreateInlinePaymentRequest (..),
    CreateLinkedPaymentRequest (..),
    CreateVerifiedPaymentRequest (..),
    BaseAchPaymentCreateRequestAttributes (..),
    PlaidProcessorToken (..),
  )
where

import Data.Aeson (ToJSON (toJSON), (.:), (.:?), (.=))
import qualified Data.Aeson as J
import qualified Data.OpenApi as OpenApi
import qualified Data.Text as T
import GHC.Generics (Generic)
import qualified Network.Integrated.HTTP.Core as Time
import TheUnit.Model.Common (Tags, UnitJSONObject (..))
import TheUnit.Model.Core (mergeAesonObjects, (.->), _omitNulls)
import TheUnit.Model.Payment.PaymentStatus (Direction, PaymentStatus)
import TheUnit.Model.Relationships (AccountId, CounterpartyId, CustomerId, RecurringPaymentId, TransactionId)
import Prelude hiding (id)

data ACHPayment = ACHPayment
  { -- | Identifier of the ACH payment resource.
    id :: !T.Text,
    -- | The Deposit Account originating the transfer.
    accountId :: !AccountId,
    -- | The date the resource was created.
    -- RFC3339 Date string "2020-01-13T16:01:19.346Z"
    createdAt :: !Time.DateTime,
    -- | One of Pending, Rejected, Clearing, Sent, Canceled, Returned. See [ACH Status](https://developers.unit.co/#ach-status).
    status :: !PaymentStatus,
    -- | Optional. More information about the status.
    reason :: !(Maybe T.Text),
    -- | The party on the other side of the ACH payment.
    counterparty :: !Counterparty,
    -- | The direction in which the funds flow (either Debit or Credit).
    -- |
    direction :: !Direction,
    -- | Payment description (maximum of 10 characters), also known as Company Entry Description, this will show up on statement of the counterparty.
    description :: !(Maybe T.Text),
    -- | Optional, additional payment description (maximum of 50 characters), not all institutions present that.
    addenda :: !(Maybe T.Text),
    -- | The amount (cents) of the payment.
    amount :: !Int,
    -- | Optional, For ACH debit with statuses Pending,Clearing, shows the date on which the payment will be settled.
    settlementDate :: !(Maybe Time.Date),
    -- | Optional, For ACH credit with statuses Pending,Sent, shows the date on which the counterparty will handle the request.
    expectedCompletionDate :: !(Maybe Time.Date),
    -- | Optional, shows the verification method of the counterparty : 'Plaid'.
    counterpartyVerificationMethod :: !(Maybe T.Text),
    -- | Indicates whether the payment is a Same Day ACH payment. See [Same Day ACH](https://docs.unit.co/ach-origination#same-day-ach).
    sameDay :: !Bool,
    -- | The Customer the deposit account belongs to. This relationship is only available if the account belongs to a single customer, business or individual
    customer :: !(Maybe CustomerId),
    -- | The Counterparty the payment to be made to.
    counterpartyId :: !(Maybe CounterpartyId),
    -- | Optional. The transaction generated by this payment. Generated instantly in cases where a credit ach payment is converted to a book payment, otherwise, once the payment is sent.
    transaction :: !(Maybe TransactionId),
    -- | The recurring payment belonging to this payment.
    recurringPayment :: !(Maybe RecurringPaymentId)
  }
  deriving (Show, Generic)

instance Eq ACHPayment where
  ACHPayment {id = idL} == ACHPayment {id = idR} = idL == idR

instance J.FromJSON ACHPayment where
  parseJSON = J.withObject "ACHPayment" \o -> do
    ("achPayment" :: T.Text) <- o .: "type"
    attributes <- o .: "attributes"
    relationships <- o .: "relationships"

    _id <- o .: "id"
    createdAt <- attributes .: "createdAt"
    amount <- attributes .: "amount"
    direction <- attributes .: "direction"
    description <- attributes .:? "description"
    addenda <- attributes .:? "addenda"
    status <- attributes .: "status"
    reason <- attributes .:? "reason"
    counterparty <- attributes .: "counterparty"

    settlementDate <- attributes .:? "settlementDate"
    expectedCompletionDate <- attributes .:? "expectedCompletionDate"
    counterpartyVerificationMethod <- attributes .:? "counterpartyVerificationMethod"
    sameDay <- attributes .: "sameDay"

    accountId <- relationships .: "account"
    customer <- relationships .:? "customer"
    transaction <- relationships .:? "transaction"
    recurringPayment <- relationships .:? "recurringPayment"
    counterpartyId <- relationships .:? "counterparty"

    pure $ ACHPayment {id = _id, ..}

instance J.ToJSON ACHPayment where
  toJSON ACHPayment {..} =
    let attributes =
          _omitNulls
            [ "createdAt" .= createdAt,
              "amount" .= amount,
              "direction" .= direction,
              "description" .= description,
              "addenda" .= addenda,
              "status" .= status,
              "reason" .= reason,
              "counterparty" .= counterparty,
              "settlementDate" .= settlementDate,
              "expectedCompletionDate" .= expectedCompletionDate,
              "counterpartyVerificationMethod" .= counterpartyVerificationMethod,
              "sameDay" .= sameDay
            ]
        relationships =
          _omitNulls
            [ "customer" .= customer,
              "account" .= accountId,
              "counterparty" .= counterpartyId,
              "transaction" .= transaction
            ]
     in toJSON UnitJSONObject {objId = id, typeName = "achPayment", attributes, relationships}

--     _omitNulls ["id" .= id, "type" .= ("achPayment" :: T.Text), "attributes" .= attributes, "relationships" .= relationships]

data Counterparty = CounterpartyObject
  { -- | Valid 9-digit ABA routing transit number.
    routingNumber :: !T.Text,
    -- | Bank account number.
    accountNumber :: !T.Text,
    -- | Either Checking or Savings.
    accountType :: !T.Text,
    -- | Name of the person or company that owns the bank account.
    name :: !T.Text
  }
  deriving (Eq, Generic)
  deriving anyclass (J.FromJSON, J.ToJSON, OpenApi.ToSchema)

instance Show Counterparty where
  show CounterpartyObject {accountType, name} =
    T.unpack $ "DepositoryAccountACH {routingNumber = <HIDDEN>, accountNumber = <HIDDEN>, accountType = " <> accountType <> ", name = " <> name <> "}"

--- Request

data BaseAchPaymentCreateRequestAttributes = BaseAchPaymentCreateRequestAttributes
  { -- | The amount (in cents).
    amount :: !Int,
    -- | The direction in which the funds flow.
    direction :: !Direction,
    -- | Payment description (maximum of 10 characters), also known as Company Entry Description, this will show up on statement of the counterparty.
    description :: !String,
    -- | Optional, additional payment description (maximum of 50 characters), not all institutions present that.
    addenda :: !(Maybe String),
    -- | Optional, default is false. Verify the counterparty balance, if balance verification fails the payment will be rejected with reason set to CounterpartyInsufficientFunds
    verifyCounterpartyBalance :: !(Maybe Bool),
    -- | Optional, default is false. See [Same Day ACH](https://docs.unit.co/ach-origination/#same-day-ach).
    sameDay :: !(Maybe Bool),
    -- | See [Idempotency](https://docs.unit.co/#intro-idempotency).
    idempotencyKey :: !String,
    -- | See [Tags](https://developers.unit.co/#tags). Tags that will be copied to any transaction that this payment creates (see [Tag Inheritance](https://developers.unit.co/#tag-inheritance)).
    tags :: !(Maybe Tags)
  }
  deriving (Show, Generic)
  deriving anyclass (J.FromJSON, J.ToJSON, OpenApi.ToSchema)

-- | Originates an ACH payment to a counterparty which is specified inline (vs to a linked Counterparty Resource).
-- NOTE:
-- Originating ACH debits requires capturing the authorization of the account owner and therefore originating ACH debits to inline counterparties is not allowed by default. If your use case requires this capability, please contact Unit.
data CreateInlinePaymentRequest = CreateInlinePaymentRequest
  { attributes :: !BaseAchPaymentCreateRequestAttributes,
    counterparty :: !Counterparty,
    accountId :: !AccountId
  }
  deriving (Show, Generic)
  deriving anyclass (OpenApi.ToSchema)

instance J.ToJSON CreateInlinePaymentRequest where
  toJSON CreateInlinePaymentRequest {..} =
    let attributes' =
          mergeAesonObjects
            [ toJSON attributes,
              _omitNulls ["counterparty" .= counterparty]
            ]
     in _omitNulls
          [ "type" .= J.String "achPayment",
            "attributes" .= attributes',
            "relationships" .= J.object ["account" .= accountId]
          ]

instance J.FromJSON CreateInlinePaymentRequest where
  parseJSON = J.withObject "CreateInlinePaymentRequest " \o -> do
    ("achPayment" :: T.Text) <- o .: "type"
    attributes <- o .: "attributes"
    counterparty <- o .: "attributes" .-> "counterparty"
    relationships <- o .: "relationships"
    accountId <- relationships .: "account"
    pure CreateInlinePaymentRequest {..}

data CreateLinkedPaymentRequest = CreateLinkedPaymentRequest
  { attributes :: !BaseAchPaymentCreateRequestAttributes,
    counterpartyId :: !CounterpartyId,
    accountId :: !AccountId
  }
  deriving (Show, Generic)
  deriving anyclass (OpenApi.ToSchema)

instance J.ToJSON CreateLinkedPaymentRequest where
  toJSON CreateLinkedPaymentRequest {..} =
    _omitNulls
      [ "type" .= J.String "achPayment",
        "attributes" .= attributes,
        "relationships" .= J.object ["account" .= accountId, "counterparty" .= counterpartyId]
      ]

instance J.FromJSON CreateLinkedPaymentRequest where
  parseJSON = J.withObject "CreateLinkedPaymentRequest" \o -> do
    ("achPayment" :: T.Text) <- o .: "type"
    attributes <- o .: "attributes"
    relationships <- o .: "relationships"
    accountId <- relationships .: "account"
    counterpartyId <- relationships .: "counterparty"
    pure CreateLinkedPaymentRequest {..}

-- | Processor token endpoints are used to create tokens that are then sent to a Plaid partner for use in a Plaid integration.
-- [Processor endpoints](https://plaid.com/docs/api/processors/)
data PlaidProcessorToken = PlaidProcessorToken
  { -- Name of the person or company that owns the counterparty bank account.
    counterpartyName :: !(Maybe T.Text),
    -- The processor_token that can then be used by the Plaid partner to make API requests
    -- See [Create Plaid processor token API](https://plaid.com/docs/api/processors/).
    plaidProcessorToken :: !T.Text
  }
  deriving (Show, Generic)
  deriving anyclass (J.FromJSON, J.ToJSON, OpenApi.ToSchema)

-- | Originates an ACH payment to a counterparty which is verified by Plaid.
-- INFO:
-- For more information on using Plaid, please read Unit's [Plaid partnership guide](https://guides.unit.co/partnerships/plaid)
data CreateVerifiedPaymentRequest = CreateVerifiedPaymentRequest
  { attributes :: !BaseAchPaymentCreateRequestAttributes,
    plaidProcessorToken :: !PlaidProcessorToken,
    accountId :: !AccountId
  }
  deriving (Show, Generic)
  deriving anyclass (OpenApi.ToSchema)

instance J.ToJSON CreateVerifiedPaymentRequest where
  toJSON CreateVerifiedPaymentRequest {..} =
    let toJSON' v = J.genericToJSON J.defaultOptions {J.omitNothingFields = True} v
        attributes' =
          mergeAesonObjects
            [ toJSON' attributes,
              toJSON' plaidProcessorToken
            ]
     in _omitNulls
          [ "type" .= J.String "achPayment",
            "attributes" .= attributes',
            "relationships" .= J.object ["account" .= accountId]
          ]

instance J.FromJSON CreateVerifiedPaymentRequest where
  parseJSON = J.withObject "CreateVerifiedPaymentRequest" \o -> do
    ("achPayment" :: T.Text) <- o .: "type"
    attributes <- o .: "attributes"
    plaidProcessorToken <- o .: "attributes"

    relationships <- o .: "relationships"
    accountId <- relationships .: "account"
    pure CreateVerifiedPaymentRequest {..}
